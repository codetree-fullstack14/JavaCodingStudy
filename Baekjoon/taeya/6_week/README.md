## 문제 풀이 회고

### 문제 백준 10026 적록색약

### 문제 요약
N x N 입력값에 RGB가 들어옴,
일반인이 본 구역 분할과 적록색맹이 본 구역분할을 공백 구분 순차 출력

### 문제 풀이(알고리즘)
격자 입력 값을 DFS, BFS 등을 이용해서 같은 색일 때 탐색을 진행해서 구역 갯수 세기
// 내 구현 방법
// 1. 입력값을 int형 양수값으로 받는다. - 계산하기 편하게
// 2. dfs 를 진행. 방문 여부는 현재 맵을 -1을 곱하여 넣어두기 - 공간효울성을 높일 수 있다.
// 3. dfs가 호출 될 때마다 일반 값 증가
// 4. 음수를 기준으로 -3이상이나 미만이냐를 통해 맵 재비교
// 5. dfs가 호출 될 때마다 적록 값 증가
// 6. 출력

// 개선점
// 1. 입력값을 char형으로 받는다. = 코드 명확성을 높일 수 있다.
// 2. 입력값을 받을 때 적록 값과 일반 값을 동시에 받는다.
// 3. dfs가 호출 될 때마다 count 한다.
// 4. 방문 여부를 판단하는 맵을 만들고, 처음 입력받았던 색과 현재 탐색 중인 색을 비교해서 다르면 탈출

### 피드백 및 배운점

DFS 에서 맵을 넘는지 확인하는 조건코드에서 맵의 값을 먼저 조건에 걸면 배열 인덱스 아웃 오브 바운스 예외 가 뜸.

---
### 문제 백준 1005 ACM Craft

### 문제 요약

### 문제 풀이(알고리즘)

### 피드백 및 배운점

---
### 문제 백준 2668 숫자고르기 

### 문제 요약
N까지의 입력값에 각각 N까지의 랜덤한 value를 가지고 key와 value의 집합이 일치하는 집합의 갯수와 value값 오름차순 정렬 출력
// 1~N 의 key 값과 랜덤 중복으로 입력되는 value 값이 있음.
// key값과 value값의 각각의 집합이 일치하는 최대치
// 정수의 개수와 뽑은 정수들을 오름차순으로 차례로 출력

### 문제 풀이(알고리즘)
// key를 뽑고 해당 value를 가진 key값의 value를 조사
// key == value는 패스
// 어떤 알고리즘?
// DP x - 이전 값을 계속해서 저장할 필요는 없음.
// dfs - key값의 value값을 key로 따라간 뒤, 마지막에 두 집합이 동일한지 비교
// 두 집합을 비교할 필요 없이 사이클이 형성되는지 판단하면 끝

// 어떤 자료구조?
// 방법 1. stack을 이용해서 모든 value값 탐색 - bfs 방식이긴 하지만 dfs와 동일하게 동작(길이 하나뿐이기 때문)
// 방법 2. 방문 부울리언 배열 이용

### 피드백 및 배운점

---
### 문제 백준 2110 공유기 설치

### 문제 요약
// 집의 개수, 공유기 개수
// x축 상의 집 좌표들
// 공유기를 설치했을 때, 가장 인접한 공유기간 최대 거리

### 문제 풀이(알고리즘)
// x 좌표가 크다 -> long형으로
// 모든 공유기를 설치하면서 적절한 위치에 설치하는 방법..

// 이 문제의 까다로운점
// 모든 x좌표에 건물이 있는게 아님.
// 설치해야하는 공유기의 개수가 정해져 있음.
// 건물 간 간격이 일정하지 않음.
// 공유기를 설치할 때마다 이전의 계산값이 초기화 됨..

// 검색해보니 이분 탐색이라고 함.

### 피드백 및 배운점


